export declare function isOdd(n: number): boolean;
export declare const seq: (adjust?: number) => (adjustMin?: number) => (start: number, end?: number | undefined, step?: number) => number[];
export declare function selector(...rest: (number | number[])[]): {
    (val: any, index: number): boolean;
};
export declare function flatten<T>(...rest: (T | T[])[]): T[];
export declare function arrayrify<T, R>(fn: (x: T, ...rest: any[]) => R): (x: T | T[], ...rest: any[]) => R | R[];
export declare function multiplex(fn: (...rest: (any | any[])[]) => any): (...rest: any[]) => any;
export declare function asArray(fn: (...rest: (any | any[])[]) => any): (...rest: any[]) => any[];
declare function possibleScalar<T>(x: T[]): T | T[];
export { possibleScalar };
export declare function multiplexer(...rest: (any | any[])[]): (fn: (...rest: any[]) => any) => any;
export declare const map: (xx: {}) => (fn: (x: any, idx?: string | number | undefined) => any) => any;
export declare const each: (xx: {}) => (fn: (x: any, idx?: string | number | undefined) => any) => any;
export declare function numberPrecision(prec?: number): (x: import("src/lib/types").numVector, ...rest: any[]) => import("src/lib/types").numVector;
export declare function any<T>(x: T[]): (fn: any) => boolean;
export declare function sum(x: any[]): number;
export declare const div: (...rest: any[]) => any;
export declare const mult: (...rest: any[]) => any;
export interface ISummary {
    N: number;
    mu: number;
    population: {
        variance: number;
        sd: number;
    };
    sample: {
        variance: number;
        sd: number;
    };
    relX: any;
    relX2: any;
    stats: {
        min: number;
        '1st Qu.': number;
        median: number;
        '3rd Qu.': number;
        max: number;
    };
}
export declare function summary(x: number[]): ISummary;
export declare function Welch_Satterthwaite(s: number[], n: number[]): number;
